4. Option A [ Alexa best choice ]

[ v2 ] Project Notifier Publisher/Subscriber

Option A (Laravel) - BEST FIT for Alexa

Approach 1 : Inside

First WARP proposal described here :

laravel-project/
├── app/
│   ├── Models/ (existing Laravel)
│   ├── Domain/
│   ├── Application/
│   └── Infrastructure/

laravel-project/
├── app/
│   ├── Domain/ (pure business logic)
│   ├── Application/ (use cases)
│   ├── Infrastructure/
│   │   ├── Repositories/
│   │   └── Alexa/ (NEW - Alexa-specific adapters)
│   │       ├── AlexaSkillController.php
│   │       ├── AlexaResponseBuilder.php
│   │       ├── AlexaAccountLinker.php
│   │       └── AlexaWebhookHandler.php
│   └── Http/
│       └── Controllers/
│           ├── Api/ (traditional API)
│           └── Alexa/ (Alexa Skills endpoints)
├── routes/
│   ├── api.php
│   └── alexa.php (NEW - Alexa-specific routes)
└── config/
    └── alexa.php (NEW - Alexa configuration)

State of Laravel Development before the start of Sprint 1

Actual Architecture Analysis made by WARP

What You've Built (Excellent Foundation!):

Domain Models

✅ User (with roles: admin, publisher, subscriber)

✅ Publisher (business entity with CIF, address, subscriber limits)

✅ Subscriber (personal profiles with demographics)

✅ PublisherList (content categories - this is brilliant!)

✅ Subscription (many-to-many through publisher_lists)

✅ Notification (with types: in-app, SMS, mail, push)

Key Architecture Insights

PublisherList as Content Categories - This is a great design choice!
◦ Publishers can have multiple content lists (topics/categories)
◦ Each list can be private or public
◦ Subscribers subscribe to specific lists, not just publishers

Clean Separation of Concerns:
◦ User authentication separate from Publisher/Subscriber profiles
◦ Business logic for publishers (CIF, max subscribers)
◦ Rich subscriber demographics

Observer Pattern Implementation:
◦ NotificationObserver ready for handling notification events
◦ Perfect foundation for Alexa notifications!

Current Data Flow

User → Publisher → PublisherList ← Subscription → Subscriber ← User
                        ↓
                  Notification

Verdict : Perfect for Hexagonal Architecture!

3. Alexa Rules !!!

2 Choices for Option A

Approach 1 : Inside

First WARP proposal described here :

laravel-project/
├── app/
│   ├── Models/ (existing Laravel)
│   ├── Domain/
│   ├── Application/
│   └── Infrastructure/

laravel-project/
├── app/
│   ├── Domain/ (pure business logic)
│   ├── Application/ (use cases)
│   ├── Infrastructure/
│   │   ├── Repositories/
│   │   └── Alexa/ (NEW - Alexa-specific adapters)
│   │       ├── AlexaSkillController.php
│   │       ├── AlexaResponseBuilder.php
│   │       ├── AlexaAccountLinker.php
│   │       └── AlexaWebhookHandler.php
│   └── Http/
│       └── Controllers/
│           ├── Api/ (traditional API)
│           └── Alexa/ (Alexa Skills endpoints)
├── routes/
│   ├── api.php
│   └── alexa.php (NEW - Alexa-specific routes)
└── config/
    └── alexa.php (NEW - Alexa configuration)

Approach 2 : Outside

As showed in YouTube tutorial :

DDD en Laravel : Desintoxicándonos de Eloquent

laravel-project/
├── app/ (keep existing Laravel structure)
├── src/ (NEW - pure business logic)
│   ├── Domain/
│   ├── Application/
│   └── Infrastructure/
└── composer.json (updated autoload)

BEST CHOICE : OPTION A → APPROACH 2

Why

1. True Framework Independence

src/ (completely Laravel-agnostic)
├── Domain/
├── Application/
└── Infrastructure/
    ├── Laravel/ (one adapter)
    ├── Symfony/ (could add later)
    └── CLI/ (could add later)

2. Mental Separation

app/ = Laravel-specific code

src/ = Your business logic (portable)

3. Testing Benefits

Unit tests for src/ don't need Laravel bootstrap

Faster test execution

True isolation testing

3. Future-Proof

Easy to extract src/ into separate package

Could become a standalone library

Microservices ready

Team Understanding

Clear boundary: "Don't put Laravel stuff in src/"

Forces true hexagonal thinking

Updated Structure with

observers-hexagonal/laravel/
├── app/ (EXISTING Laravel structure - keep untouched)
│   ├── Models/ (existing - become Infrastructure adapters)
│   ├── Http/Controllers/
│   ├── Observers/
│   └── Providers/
├── src/ (NEW - pure business logic, zero Laravel dependencies)
│   ├── ObserversHex/ (your app namespace)
│   │   ├── Domain/
│   │   │   ├── Publisher/
│   │   │   │   ├── Entities/
│   │   │   │   │   ├── Publisher.php
│   │   │   │   │   └── PublisherList.php
│   │   │   │   ├── ValueObjects/
│   │   │   │   │   ├── PublisherId.php
│   │   │   │   │   └── CIF.php
│   │   │   │   ├── Services/
│   │   │   │   │   └── PublisherListService.php
│   │   │   │   └── Repositories/
│   │   │   │       └── PublisherRepositoryInterface.php
│   │   │   ├── Subscriber/
│   │   │   ├── Notification/
│   │   │   └── Shared/
│   │   ├── Application/
│   │   │   ├── UseCases/
│   │   │   │   ├── GetUserNotificationsUseCase.php
│   │   │   │   ├── SubscribeToPublisherListUseCase.php
│   │   │   │   └── GetPublisherListNotificationsUseCase.php
│   │   │   ├── DTOs/
│   │   │   └── Ports/
│   │   └── Infrastructure/
│   │       ├── Laravel/ (adapters to your existing models)
│   │       │   ├── Repositories/
│   │       │   │   ├── LaravelUserRepository.php
│   │       │   │   ├── LaravelPublisherRepository.php
│   │       │   │   └── LaravelNotificationRepository.php
│   │       │   └── Models/ (bridges to app/Models)
│   │       ├── Alexa/
│   │       │   ├── AlexaSkillController.php
│   │       │   ├── AlexaResponseBuilder.php
│   │       │   └── AlexaVoiceAdapter.php
│   │       └── Persistence/
│   │           └── InMemory/ (for testing)
├── composer.json (UPDATED autoload)
└── tests/
    ├── Unit/
    │   └── src/ (tests for src/ - no Laravel)
    └── Feature/
        └── app/ (Laravel integration tests)

Composer Autoload Update

{
    "autoload": {
        "psr-4": {
            "App\\": "app/",
            "ObserversHex\\": "src/ObserversHex/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Tests\\": "tests/"
        }
    }
}

Benefits in Our Case

1. Alexa Independence

// Pure domain logic (no Laravel dependencies)
namespace ObserversHex\Application\UseCases;

class GetUserNotificationsUseCase 
{
    // Could work with ANY framework
}

2. Clean Separation

Your existing Laravel models stay in

Pure business logic lives in

Adapters bridge between them

3. Testing Strategy

// Fast unit tests (no Laravel)
tests/Unit/src/Domain/PublisherTest.php

// Integration tests (with Laravel)  
tests/Feature/app/AlexaControllerTest.php

Migration Path

Create

Keep existing

Build adapters to connect them

Migrate gradually piece by piece

Final Verdict

Use the

The

README_dev.md

This README is for developers who want to understand the architectural thinking, capturing the real essence of our architectural discussion.

What This README Actually Contains

🧠 The "Why" Behind Every Decision

Why username-based integration instead of OAuth

Why

Why start with monolith instead of microservices

Why Alexa first instead of web interface

🎯 Technical Insights From Our Discussion

The brilliance of

How your existing models reveal sophisticated domain design

The three architecture options we evaluated and why we chose our path

The microservices evolution strategy based on real scalability needs

🏗️ Architecture Rationale

Why Laravel is just an infrastructure adapter in true hexagonal architecture

How voice commands naturally map to use cases

Why username-based integration enables perfect microservices boundaries

How domain-driven design principles guide technical decisions

🚀 Real-World Scalability

The hosting flexibility insight (each service on optimal platform)

How to add new channels without touching existing code

The evolutionary path from monolith to distributed services